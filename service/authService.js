const { User, sequelize } = require("../models");
const bcrypt = require("bcryptjs");
const _ = require("lodash");
const jwt = require("jsonwebtoken");
const nodemailer = require("nodemailer");
require("dotenv").config();
const moment = require("moment-timezone");
const { error } = require("console");

const KEY_TOKEN_RESET_PASS = process.env.KEY_TOKEN_RESET_PASS;
const EMAIL_ADMIN = process.env.EMAIL_ADMIN;
const PASS_ADMIN = process.env.PASS_ADMIN;
const URL_CLIENT_BASE = process.env.URL_CLIENT_BASE;
const KEY_ACCESS_TOKEN = process.env.KEY_ACCESS_TOKEN;
const KEY_REFRESH_TOKEN = process.env.KEY_REFRESH_TOKEN;

// L·∫•y th·ªùi gian hi·ªán t·∫°i theo GMT+7
const issuedAt = Math.floor(moment().tz("Asia/Ho_Chi_Minh").valueOf() / 1000);
const expiresInAccessToken = issuedAt + 24 * 60 * 60; // 1 ng√†y
const expiresInRefreshToken = issuedAt + 7 * 24 * 60 * 60; // 7 ng√†y

const Login = async ({ email, password }) => {
  try {
    email = _.trim(email);
    password = _.trim(password);

    const check = await User.findOne({ where: { email } });

    if (!check) {
      return { status: 401, success: false, error: true, message: "Email kh√¥ng t·ªìn t·∫°i trong h·ªá th·ªëng!" };
    }

    if(check.dataValues.is_active === false) {
      return { 
        status: 403, 
        success: false, 
        error: true, 
        message: "T√†i kho·∫£n ch∆∞a ƒë∆∞·ª£c k√≠ch ho·∫°t! Vui l√≤ng k√≠ch ho·∫°t t√†i kho·∫£n"};
    }

    const checkPass = await bcrypt.compare(password, check.dataValues.password);

    if (checkPass) {
      const accessToken = jwt.sign(
        {
          id: check.dataValues.id,
          role: check.dataValues.role,
          username: check.dataValues.username,
          email: check.dataValues.email,
          image: check.dataValues.image,
        },
        KEY_ACCESS_TOKEN,
        { expiresIn: '1d' }
      );
      const refreshToken = jwt.sign(
        {
          id: check.dataValues.id,
        },
        KEY_REFRESH_TOKEN,
        { expiresIn: '7d' } // H·∫øt h·∫°n sau 7 ng√†y
      );

      return {
        status: 200,
        success: true, 
        error: false,
        data: {
          accessToken,
          refreshToken,
          id: check.dataValues.id,
          role: check.dataValues.role,
        },
        message: "ƒêƒÉng nh·∫≠p th√†nh c√¥ng!",
      };
    } else {
      return { status: 401, error: true, success: false, message: "Sai t√†i kho·∫£n ho·∫∑c m·∫≠t kh·∫©u!" };
    }
  } catch (error) {
    console.error("Error login user", error.message);
    return { status: 500, error: true, success: false, message: "Internal Server Error" };
  }
};

const Register = async ({ username, email, password, image }) => {
  try {
    username = _.trim(username);
    email = _.trim(email);

    const checkEmail = await User.findOne({ where: { email } });
    if (checkEmail) {
      return {
        status: 401,
        error: true,
        success: false,
        field: "email",
        message: "Email ƒë√£ t·ªìn t·∫°i trong h·ªá th·ªëng!",
      };
    }

    const salt = bcrypt.genSaltSync(10);
    password = bcrypt.hashSync(password, salt);

    const transaction = await sequelize.transaction();

    const user = await User.create({ username, email, password, image });

    await sendEmailActiveAccount({email});
    
    await transaction.commit(); 

    const message = "ƒêƒÉng k√Ω th√†nh c√¥ng! Vui l√≤ng ki·ªÉm tra email ƒë·ªÉ x√°c th·ª±c.";
    return { status: 200, error: false, success: true, user, message };
  } catch (error) {
    await transaction.rollback(); 
    console.error("Error regiter user", error.message);
    return { status: 500, error: true, success: false, message: "Internal Server Error" };
  }
};

const checkEmail = async ({ email, image }) => {
  try {
    const check = await User.findOne({ where: { email } });
    if (check) {
      if (check.dataValues.image == null) {
        await User.update({ image }, { where: { id: check.id } });
      }
      if(check.dataValues.is_active === false) {
        await User.update({ is_active: true }, { where: { id: check.id } });
        }
      const accessToken = jwt.sign(
        {
          id: check.dataValues.id,
          role: check.dataValues.role,
          username: check.dataValues.username,
          email: check.dataValues.email,
          image: check.dataValues.image,
          iat: issuedAt,
          exp: expiresInAccessToken, // H·∫øt h·∫°n sau 7 ng√†y theo GMT+7
        },
        KEY_ACCESS_TOKEN
      );
      const refreshToken = jwt.sign(
        {
          id: check.dataValues.id,
          iat: issuedAt,
          exp: expiresInRefreshToken, // H·∫øt h·∫°n sau 7 ng√†y theo GMT+7
        },
        KEY_REFRESH_TOKEN
      );

      return {
        status: 200,
        data: {
          accessToken,
          refreshToken,
          id: check.dataValues.id,
          role: check.dataValues.role,
        },
      };
    } else {
      return { status: 401, message: "Email not found in the system" };
    }
  } catch (error) {
    console.error("Error reset password", error.message);
    return { status: 500, message: "Internal Server Error" };
  }
};

const forgotPassword = async (email) => {
  try {
    const user = await User.findOne({ where: { email } });
    if (!user) {
      return { success: false, error: true, status: 404, message: "Email kh√¥ng t·ªìn t·∫°i trong h·ªá th·ªëng!" };
    }

    const resetToken = jwt.sign(
      {
        id: user.id,
        email: user.email,
        iat: issuedAt,
        exp: expiresInAccessToken, // H·∫øt h·∫°n sau 1 hour theo GMT+7
      },
      KEY_TOKEN_RESET_PASS
    );

    const emailResponse = await sendEmail({ email, token: resetToken });
    if (emailResponse.status === 500) {
      return { status: 500, message: "G·ª≠i email th·∫•t b·∫°i!" };
    }

    return {
      success: true,
      error: false,
      status: 200,
      message: "Vui l√≤ng ki·ªÉm tra email ƒë·ªÉ ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u!",
    };
  } catch (error) {
    console.error("L·ªói qu√™n m·∫≠t kh·∫©u:", error.message);
    return { status: 500, message: "L·ªói m√°y ch·ªß n·ªôi b·ªô" };
  }
};

const sendEmail = async ({ email, token }) => {
  try {
    const transporter = nodemailer.createTransport({
      service: "Gmail",
      auth: {
        user: EMAIL_ADMIN,
        pass: PASS_ADMIN,
      },
    });

    const resetLink = `${URL_CLIENT_BASE}/reset-password?token=${token}&email=${email}`;

    const mailOptions = {
      from: `"Ferg Cinema" <${EMAIL_ADMIN}>`,
      to: email,
      subject: "Y√™u c·∫ßu ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u",
      html: `
                <div style="max-width: 500px; margin: auto; padding: 20px; border: 1px solid #ddd; border-radius: 10px; font-family: Arial, sans-serif; background-color: #f9f9f9;">
                    <div style="text-align: center;">
                        <h2 style="color: #ff9900;">üêù Ferg Cinema</h2>
                        <h3 style="color: #333;">ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u</h3>
                    </div>
                    <p style="font-size: 16px; color: #555;">B·∫°n ƒë√£ y√™u c·∫ßu ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u cho t√†i kho·∫£n c·ªßa m√¨nh.</p>
                    <p style="font-size: 16px; color: #555;">Vui l√≤ng nh·∫•p v√†o li√™n k·∫øt b√™n d∆∞·ªõi ƒë·ªÉ ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u:</p>
                    <div style="text-align: center; margin: 20px 0;">
                        <a href="${resetLink}" style="display: inline-block; background-color: #ff9900; color: #fff; padding: 12px 20px; text-decoration: none; font-weight: bold; border-radius: 5px;">
                            ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u
                        </a>
                    </div>
                    <p style="font-size: 14px; color: #888;">N·∫øu b·∫°n kh√¥ng y√™u c·∫ßu thao t√°c n√†y, vui l√≤ng b·ªè qua email n√†y.</p>
                </div>
            `,
    };

    await transporter.sendMail(mailOptions);
    return { status: 200, message: "Email ƒë√£ ƒë∆∞·ª£c g·ª≠i th√†nh c√¥ng!" };
  } catch (error) {
    console.error("L·ªói g·ª≠i email:", error.message);
    return { status: 500, message: "L·ªói m√°y ch·ªß n·ªôi b·ªô!" };
  }
};

const newPassword = async ({ email, token, password }) => {
  try {
    const decoded = jwt.verify(token, KEY_TOKEN_RESET_PASS);
    const user = await User.findOne({ where: { email, id: decoded.id } });
    if (!user)
      return { status: 400, message: "Token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n!" };

    const salt = bcrypt.genSaltSync(10);
    const hashedPassword = bcrypt.hashSync(password, salt);
    user.password = hashedPassword;
    await user.save();

    return { status: 201, message: "M·∫≠t kh·∫©u ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng!" };
  } catch (error) {
    console.error("L·ªói g·ª≠i email:", error.message);
    return { status: 500, message: error.message };
  }
};

const sendEmailActiveAccount = async ({ email}) => {
  try {
    const user = await User.findOne({ where: { email } });
    if (!user) {
      return { status: 404, error: true, success: false, message: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i!" };
    }

    const username = user.username || email; // S·ª≠ d·ª•ng email n·∫øu kh√¥ng c√≥ t√™n ng∆∞·ªùi d√πng

    const token = jwt.sign(
      {
        id: user.id,
      },
      KEY_ACCESS_TOKEN,
      { expiresIn: '1h' }
    );

    const transporter = nodemailer.createTransport({
      service: "Gmail",
      auth: {
        user: EMAIL_ADMIN,
        pass: PASS_ADMIN,
      },
    });

    const activeLink = `${URL_CLIENT_BASE}/active-account?token=${token}&email=${email}`;

    const mailOptions = {
      from: `"Ferg Cinema" <${EMAIL_ADMIN}>`,
      to: email,
      subject: "X√°c th·ª±c t√†i kho·∫£n Ferg Cinema",
      html: `
        <div style="max-width: 500px; margin: auto; padding: 20px; border: 1px solid #ddd; border-radius: 10px; font-family: Arial, sans-serif; background-color: #f9f9f9;">
          <div style="text-align: center;">
            <h2 style="color: #ff9900;">üêù Ferg Cinema</h2>
            <h3 style="color: #333;">Ch√†o m·ª´ng, ${username}!</h3>
          </div>
          <p style="font-size: 16px; color: #555;">C·∫£m ∆°n b·∫°n ƒë√£ ƒëƒÉng k√Ω t√†i kho·∫£n t·∫°i <strong>Ferg Cinema</strong>.</p>
          <p style="font-size: 16px; color: #555;">Vui l√≤ng nh·∫•p v√†o n√∫t b√™n d∆∞·ªõi ƒë·ªÉ k√≠ch ho·∫°t t√†i kho·∫£n c·ªßa b·∫°n.</p>
          <div style="text-align: center; margin: 20px 0;">
            <a href="${activeLink}" style="display: inline-block; background-color: #ff9900; color: #fff; padding: 12px 20px; text-decoration: none; font-weight: bold; border-radius: 5px;">
              K√≠ch ho·∫°t t√†i kho·∫£n
            </a>
          </div>
          <p style="font-size: 14px; color: #ff0000; font-weight: bold; text-align: center;">
            ‚ö†Ô∏è Li√™n k·∫øt x√°c th·ª±c c√≥ hi·ªáu l·ª±c trong 1 gi·ªù.
          </p>
          <p style="font-size: 14px; color: #888;">N·∫øu b·∫°n kh√¥ng t·∫°o t√†i kho·∫£n t·∫°i Ferg Cinema, vui l√≤ng b·ªè qua email n√†y.</p>
          <p style="font-size: 14px; color: #888; margin-top: 30px;">Tr√¢n tr·ªçng,<br/>ƒê·ªôi ng≈© Ferg Cinema</p>
        </div>
      `,
    };    
    await transporter.sendMail(mailOptions);
    return { status: 200, success: true, error: false, message: "Email x√°c th·ª±c ƒë√£ ƒë∆∞·ª£c g·ª≠i th√†nh c√¥ng!" };
  } catch (error) {
    console.error("L·ªói g·ª≠i email:", error.message);
    return { status: 500, error: true, success: false, message: "L·ªói m√°y ch·ªß khi g·ª≠i email x√°c th·ª±c!" };
  }
};

const activeAccountService = async ({ email, token }) => {
  try {
    const decoded = jwt.verify(token, KEY_ACCESS_TOKEN);
    const user = await User.findOne({ where: { email, id: decoded.id } });
    if (!user)
      return { status: 400, error: true, success: false, message: "Token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n!" };

    if (user.is_active) {
      return { status: 201, success: true, error: false, message: "T√†i kho·∫£n ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t tr∆∞·ªõc ƒë√≥!!" };
    }

    user.is_active = true;
    await user.save();

    return { status: 201, success: true, error: false, message: "T√†i kho·∫£n ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t!" };
  } catch (error) {
    console.error("L·ªói g·ª≠i email:", error.message);
    return { status: 500, error: true, success: false, message: error.message };
  }
};


module.exports = {
  Login,
  Register,
  forgotPassword,
  checkEmail,
  sendEmail,
  newPassword,
  activeAccountService,
  sendEmailActiveAccount
};
